# Binary Exploitation

The focus of this page is x86 and amd64 on Linux, but there is information from other architectures and operating systems sprinkled around.

## General References

Here are some general references to start you on your journey:

* [pwnable.tw](https://pwnable.tw/): A collection of binary exploitation challenges.
* [LiveOverflow's YouTube channel](https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w): Hours and hours of amazing binary exploitation content.
* [Computer Tyme Interrupt Jump Table](http://www.ctyme.com/intr/int.htm): A reference of different interrupt codes and what they mean on different architectures.

## Dynamic Analysis

### GNU Project Debugger (GDB)

GDB (with the [GEF plugin](https://gef.readthedocs.io)) is my go-to debugger for ELF files.

#### Commands

The following table has some useful vanilla GDB basic commands and snippets that I always forget:

| Command                  | Description                                      |
| ------------------------ | ------------------------------------------------ |
| `step`                   | Step-into by source line.                        |
| `stepi`                  | Step-into by instruction.                        |
| `next`                   | Step-over by source line.                        |
| `nexti`                  | Step-over by instruction.                        |
| `info functions <regex>` | Show names and types of defined functions.       |
| `info variables <regex>` | Show names and types of global/static variables. |

The following table is the same as above, but for GEF:

| Command                  | Description                                       |
| ------------------------ | ------------------------------------------------- |
| `grep <string>`          | Search for a string in memory.                    |
| `xref 0xdeadbeef`        | Search for an address in memory.                  |
| `entry-break`            | Find a reasonable entrypoint and pause execution. |
| `telescope <addr\|reg>`   | Dump memory from a specified location.            |

#### Handling Syscalls and Signals

GDB has native support for interacting with a debugged program's syscalls and signals. Here are a couple of potentially-useful snippets:

```gdb
# Disable ptrace anti-debugging.
catch syscall ptrace
commands
    silent
    set $rax = 0
    continue
end

# Don't let the debugged program timeout.
handle SIGALRM ignore

# Pass SIGUSR1 to the debugged program.
handle SIGUSR1 nostop
```

Some of these techniques are demonstrated in [this PicoCTF 2018 writeup](https://syedfarazabrar.com/2019-07-14-picoctf-2018-be-quick-or-be-dead-3/).

#### Dumping Memory

When attached to a process, you can dump the contents of its memory in GDB. A potentially useful scenario for this technique is when dealing with a self-modifying binary. Here is the syntax:

```gdb
dump memory ./outfile 0xdeadbeef 0xcafebabe
```

A writeup which does this can be found [here](https://nankeen.me/posts/plaid-ctf-2020-reee/).

## ELFs

### Overview

The [Executable and Linkable Format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) is an executable file format for standalone binaries, shared libraries, and core dumps often used on Unix systems. One of the best ways to understand its details are in Linux's [`elf.h` source](https://github.com/torvalds/linux/blob/master/include/uapi/linux/elf.h).

### Hand-rolling ELFs

The quintessential reference for writing your own ELFs from hand is [The Teensy Files](https://www.muppetlabs.com/~breadbox/software/tiny/), which is a collection of articles exploring how to create the smallest possible ELF binary.

The [golf.so challenge](https://ctftime.org/task/11305) from Plaid CTF 2020 involved making a minimal shared object ELF (< 200 bytes) that ran an `execve` shellcode. Teams took a few different approaches, each of which is a good reference:

* [sigflag](https://www.sigflag.at/blog/2020/writeup-plaidctf2020-golfso/): This team actually wrote their solution in a C harness that used `elf.h`.
* [TeamGreyFang](https://github.com/TeamGreyFang/CTF-Writeups/tree/master/PlaidCTF2020/golf.so): An example of a nasm ELF payload, which ends with some overlapped sections and `DT_INIT` definition to get a sub-200-byte solution.

This challenge required slight modifications to the templates provided from The Teensy Files, due to the challenge involving creating a dynamic shared object. Look [here](https://docs.oracle.com/cd/E19455-01/816-0559/chapter6-42444/index.html) for a nice reference on the ELF dynamic section.

### `pwntools`'s `DynElf`

With a single arbitrary read primitive, lots of information can be determined about how an ELF is setup in memory. An interface that makes gleaning this information much simpler is `pwntools`'s [`DynElf` class](https://docs.pwntools.com/en/stable/dynelf.html). The `pwntools` documentation has some nice examples, but the following resources are a nice supplement:

* [StackOverflow: ELF link_map when linked as RELRO](https://reverseengineering.stackexchange.com/questions/6525/elf-link-map-when-linked-as-relro): A question from one of the `pwntools` authors about how to find an ELF's in-memory `link_map` structure.
* [Persian Challenge Writeup](https://hack.more.systems/writeup/2016/12/18/sharifctf7-guess-persian-nomoreblind/): A CTF writeup that uses `DynElf` and a format-string-powered read primitive to leak the challenge binary.
* [https://uaf.io/exploitation/misc/2016/04/02/Finding-Functions.html](https://uaf.io/exploitation/misc/2016/04/02/Finding-Functions.html): A blog post that explores implementing some of `DynElf`'s functionality by hand.

## Race Conditions

### File Path Racing with `renameat`

If you notice multiple accesses to a file path, you might be able to exploit a race condition. This is really just a small subset of the [TOCTTOU](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use) problem. Luckily, there is a Linux syscall for quickly swapping the names of two files: [renameat](http://man7.org/linux/man-pages/man2/rename.2.html).

LiveOverflow has [an awesome video](https://www.youtube.com/watch?v=5g137gsB9Wk) explaining the concepts behind and implementation of an exploit for one of these race conditions. A basic program for running this race between two file paths is (from a 35C3 CTF [challenge](https://github.com/sroettger/35c3ctf_chals/tree/master/logrotate/exploit)):

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <linux/fs.h>

int main(int argc, char ** argv) {
    while (1) {
        syscall(SYS_renameat2, AT_FDCWD, argv[1], AT_FDCWD, argv[2], RENAME_EXCHANGE);
    }

    return 0;
}
```

### Multi-threaded Remote Applications

Multi-threaded programs that accept an arbitrary number of remote connections present interesting opportunities for inter-thread heap corruption. An example of one such challenge comes in [`redis-lite` from zer0pts CTF 2022](https://hackmd.io/@ptr-yudai/rk8paaFZc).

## Dangerous C Functions

### Format Strings and `printf`

Sometimes you may need to reference the [`printf` glibc source](https://elixir.bootlin.com/glibc/glibc-2.28/source/stdio-common/vfprintf.c).

Some challenges that may be a useful reference include:

* [still-printf from hxpctf 2020](https://ctftime.org/task/14382): [This solution](https://github.com/Mem2019/Mem2019.github.io/blob/master/codes/hxp2020-still-printf.py) uses a bruteforcing partial overwrite of an address on the stack to leak pointers and return to main for further exploitation. Alternative solution is [here](https://gist.github.com/sroettger/016c67aec1100016b20b0691ea48dbac).

### `snprintf`

A somewhat-common function for dynamically building strings is [`snprintf`](https://www.cplusplus.com/reference/cstdio/snprintf/). This function has some foot-guns due to its not-so-intuitive return value, which will be the number of characters that *would have* been written to the buffer if the provided buffer was sufficiently large. An example of a real-world vulnerability from misuse of `snprintf` can be found in [CVE-2015-1548](https://web.archive.org/web/20150127035406/http://itinsight.hu/en/posts/articles/2015-01-23-mini-httpd/).

Semmle has detailed some common vulnerability code patterns in [this presentation](https://help.semmle.com/QL/ql-training/cpp/snprintf.html#1) and in an accompanying [GitHub Security Lab blog post](https://securitylab.github.com/research/librelp-buffer-overflow-cve-2018-1000140/).

### `select`

A non-obvious method of exploiting `select` is to flood the target process with open resources to exceed `select`'s 1024 file descriptor limit. These are helpful resources on the topic:

* [Thread explaining a CSAW CTF challenge](https://threadreaderapp.com/thread/1723398619313603068.html) that uses this technique to weaken crypto primitives in the target process
* [Usenix 2016: Flip Feng Shui: Hammering a Needle in the Software Stack](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/razavi)

## Return-oriented Programming (ROP)

### Creative Gadgets

Loading a value into `eax`/`rax` is typically a requirement for making syscalls, but if there are no easy `pop rax; ret` gadgets in the binary, then using the return value of a function call can be another method of populating `rax` with a desired value. As an example, [`alarm`](https://man7.org/linux/man-pages/man2/alarm.2.html) will return the number of seconds remaining until the previously-scheduled timer hits. So, two quick calls of `alarm` in rapid succession should return whatever value we passed via `rdi`.

## Syscalls, Sandboxing, and Shellcoding

### Tracing Syscalls

A nice addition to `pwntools` scripts is something like this to trace the execution of syscalls in the target program and your payloads:

```python
io = process(["strace", "-o", "trace.txt", "-f", PROG_PATH])
```

In similar fashion, recording executions with [rr](https://github.com/rr-debugger/rr) is also simple:

```python
io = process(["rr", "record", PROG_PATH])
```

### Syscall Tables

Best collection of syscall tables across architectures is available on [w3challs.com](https://syscalls.w3challs.com/).

Some alternatives:

* [x86 syscall table](https://web.archive.org/web/20200218024630/https://syscalls.kernelgrok.com/)
* [amd64 syscall table](https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/)

### Virtual Dynamic Shared Object (vDSO)

TODO: http://man7.org/linux/man-pages/man2/syscall.2.html

TODO: static address of vsyscall segment

### Sandbox Overview

An excellent talk covering sandbox architecture and different pitfalls is Robert Swiecki's [Escaping the (sand)box from CONFidence 2017](https://www.youtube.com/watch?v=gJpaxisyQfY).

#### `chroot` Jails

[`chroot`](https://en.wikipedia.org/wiki/Chroot) jails are a weak attempt at isolating processes (when misused for that purpose). Here are some good resources for escaping from them:

* [Escaping a chroot jail](https://filippo.io/escaping-a-chroot-jail-slash-1/): Comprehensive article that dives into the details and provides a universal `chroot` escape program.
* [Breaking Out of a Chroot Jail Using PERL](http://pentestmonkey.net/blog/chroot-breakout-perl): A shorter page that still covers some of the basics, and provides a PERL breakout script.

#### `ptrace` Sandboxing

A fundamental flaw in the application of `ptrace` to sandboxing is that it loses some context on the entry/exit of syscalls. As such, we can confuse programs that don't add their own level of tracking by generating `SIGTRAP`s via the `int3` instruction.

I haven't seen this in a challenge yet, but I think that [`process_vm_writev`](https://linux.die.net/man/2/process_vm_writev) could potentially be used as a solution for some `ptrace`-based challenge setups.

Another potenital issue with `ptrace`-based sandboxes is a TOCTUO race condition for address-based arguments in multithreaded code. See [this StackOverflow answer](https://stackoverflow.com/a/4421762) for a nice discussion on this topic.

A challenge that resulted in some creative bypasses was Plaid CTF 2020's [sandybox](https://ctftime.org/task/11319). Here are some of the notable solutions:

* [kscieslinski's solution](https://github.com/kscieslinski/CTF/tree/master/pwn/plaid2020/sandybox): Elegant solution that uses `int3` to get the `ptrace` syscall entry-exit checks out of sync. Provides a nice reversing of the challenge code that makes the solution more intuitive.
* [pasten's solution](https://github.com/oranav/ctf-writeups/tree/master/plaid20/sandybox): Discusses using 32-bit syscalls to fork the process and execute arbitrary shellcode.
* [sigflag's solution](https://www.sigflag.at/blog/2020/writeup-plaidctf2020-sandybox/): Discusses using 32-bit syscalls to set up an ORW shellcode.

#### `seccomp`

Secure Computing (i.e., [`seccomp`](http://man7.org/linux/man-pages/man2/seccomp.2.html)) is a facility implemented by the Linux kernel for transitioning a process to a "secure" state. Part of this "secure" state is filtering out syscalls so that they can no longer be executed.

A nice writeup of `seccomp` as it pertains to syscall filtering can be found [here](https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt). Another nice resource exploring some of `seccomp`'s weaknesses is [this LWN.net article](https://lwn.net/Articles/738694/).

[This writeup](https://n132.github.io/2022/07/04/S2.html) from Google CTF 2022 discusses a bypass related to sandboxing solutions that rely on `SECCOMP_RET_TRACE`.

##### `seccomp-tools`

The command-line tool [`seccomp-tools`](https://github.com/david942j/seccomp-tools) should be your first step for these types of challenges. Specifically, the `dump` sub-command will give you an idea of what syscalls are blocked by the binary's filter.

Because the analysis of this tool is performed via [`ptrace`](http://man7.org/linux/man-pages/man2/ptrace.2.html), you may have to patch binaries with anti-debugging measures in-place for `seccompt-tools` to work correctly.

#### Valgrind Sandboxing

An interesting approach to sandboxing is to implement the sandboxing logic as a [Valgrind tool](https://valgrind.org/docs/manual/writing-tools.html). See the [sandboxgrind challenge from HXP CTF 2021](http://eternal.red/2021/sandboxgrind/) for an example of such a challenge.

### 32-bit Tricks

These bypasses apply to `amd64` binaries and involve executing 32-bit ABI versions of syscalls or 32-bit code rather than their 64-bit ABI equivalents. These techniques may be easier to grok after reading [this StackOverflow Q/A](https://stackoverflow.com/questions/46087730/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code).

The first technique involves switching to 32-bit mode via the `retf` instruction. This instruction allows for switching to 32-bit mode via modification of the `CS` register. Writeups that use this trick process can be found [here](https://uaf.io/exploitation/2016/09/06/TokyoWesterns-MMA-Diary.html) and [here](https://osilayer8.makerforce.io/crossctf-quals2018/pwn/impossible_shellcoding/). If the filter does not check the architecture, then this technique is feasible.

If the challenge is an `amd64` binary and is not using [`libseccomp`](https://github.com/seccomp/libseccomp) for setting up its filters, there is a decent chance you can bypass the filters using 32-bit ABI syscalls directly (from 64-bit mode). This can be achieved by `OR`-ing the syscall number with `0x40000000`, as 32-bit syscalls have the 30th MSB set high. Writeups that exploit this fact can be found [here](https://web.archive.org/web/20200209145642/http://blog.redrocket.club/2019/04/11/midnightsunctf-quals-2019-gissa2/) and [here](https://web.archive.org/web/20200209150956/https://ctftime.org/writeup/18236).

Something to note when executing 32-bit syscalls is that they will only be able to handle 32-bit addresses (i.e., those less than 4GB). Exploit stability can be greatly enhanced by allocating memory at such an address by pairing `mmap` with the `MAP_32BIT` flag.

#### `sysenter`

Another trick that hinges on legacy behavior from 32-bit/64-bit compatibility is the Linux kernel's handling of the `sysenter` instruction. As discussed in [this writeup](https://r3billions.com/writeup-no-eeeeeeeeeeeemoji/), since the Linux kernel thinks `sysenter` should only occur in 32-bit mode, upon executing `sysexit`, the Linux kernel will actually return into some offset into the lower 32-bits of the `vdso` segment (since the kernel thinks this is where the call should have come from). This is extended in [this writeup for a similar challenge with more restrictions](https://github.com/amelkiy/write-ups/blob/master/hxp-2020/nemoji/README.md). Abusing this trick does require a strong primitive in being able to map pages at certain locations

### Other Tricks

Using `fork`, `vfork`, or `execve` (or their variants) may be a quick way to get into a new process without any filters applied to it.

In some multi-process setups, you can write from the syscall-restricted process you have exploited into the executable memory of a filter-less child process. An example of this (using procfs) can be found in [this writeup for the `writeonly` challenge from GoogleCTF 2020](https://github.com/captainGeech42/ctf-writeups/tree/master/google2020/writeonly).

It's also possible to make certain memory-allocation-related calls in a parent process fail once you have code execution in the child (via [`prlimit`](https://linux.die.net/man/2/prlimit)). An example challenge/writeup requiring this technique is [`sbxnote` from zer0pts CTF 2022](https://hackmd.io/@ptr-yudai/SJEgM1vzq).

### Creative "Gadgets"

If bypassing the filter is not possible, it is probably possible to leak the flag using a syscall that is not filtered out. [This repository](https://github.com/unixist/seccomp-bypass) has some shellcodes that use syscalls like [`sendfile`](http://man7.org/linux/man-pages/man2/sendfile.2.html) to exfiltrate a flag file's contents.

### Polyglot Shellcode

See [this writeup](https://github.com/TheMaccabees/ctf-writeups/tree/master/GoogleCTF2021/ABCARMANDAMD) for discussion on how to write ASCII-printable aarch/amd64 polyglot shellcode.

[This writeup](http://tukan.farm/2018/01/06/nope/) provides some Python scripting examples on defining the set of gadgets that you have to work with.

### Overcoming Instruction Blocklists

TODO: http://tukan.farm/2018/01/06/nope/

## Working with LIBCs

ASLR will be enabled on 99% of CTF challenges, so the target's libc will be loaded with a random base address. This means your exploit will most likely require an information leak to determine some addresses from the target process's address space. However, for some 32-bit binaries (especially when run locally vice remotely), libc base address brute-force can be a feasible option.

If you leak some addresses of symbols with known offsets from the remote target (commonly done via GOT entries or `main`'s return address into `__libc_start_main+N` off of the stack), the following resources can help you find the libc that the remote target is using:

* [libc.blukat.me](https://libc.blukat.me/) or [libc.rip](https://libc.rip/): Web applications that accept partial addresses of different symbols and tell you what libc they correspond to.
* [libc-database](https://github.com/niklasb/libc-database): A local tool that accomplishes the same as the above websites.

Managing lots of instances of libc on a system can be confusing. [This StackOverflow answer](https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host/851229#851229) provides some guidance.

## glibc Heap Exploitation

Most heap challenges are focused around exploitation of the glibc heap (i.e., the underyling data structures that you manipulate when you use `malloc`, `free`, and the associated memory allocation functions).

### Tcache

The tcache was introduced in glibc 2.26, and serves as a per-thread FIFO cache of chunks for common allocation sizes. Due to the relative ease of allocating chunks in the tcache and initial lack of kind of security protections, it quickly became a favorite target for glibc heap exploitation. Mitigations have been added over time (double-free protection, pointer mangling, etc.), but it is still an intriguing target for modern exploitation. Some really nice tcache-focused challenges/writeups include:

* [This writeup](https://faraz.faith/2019-10-27-backdoorctf-babytcache/) for a fairly straightforward tcache problem.
* [These](https://rpis.ec/blog/DawgCTF-TikTok/) [writeups](https://github.com/toomanybananas/dawgctf-2020-writeups/blob/master/pwn/tiktok/WRITEUP.md) for the TikTok challenge from DawgCTF 2020. They are both very detailed, but target glibc 2.27 before some of the more difficult tcache mitigations were added.
* The `tcache tear` and `realloc` challenges from [pwnable.tw](https://pwnable.tw/).

### Stack Pivoting to the Heap

As restrictive seccomp filters become more and more prevalent in CTF challenges, the ability to simply overwrite [one of the glibc hook functions](https://www.gnu.org/software/libc/manual/html_node/Hooks-for-Malloc.html) with a [one gadget](https://github.com/david942j/one_gadget) is not a viable exploitation option. The ideal way forward would be a method of overwriting `__free_hook` with a gadget that could easily pivot the stack to an attacker-controlled region of memory (presumably somewhere on the heap).

An excellent blog post that explains how to do exactly this can be found [here](https://blog.efiens.com/post/midas/heap-seccomp-rop/). This technique relies on the fact that we control the content being freed at the address stored in `rdi` when `__free_hook` is called. We then overwrite `__free_hook` with a gadget of the form (which should be in libc):

```asm
mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]
```

Which allows us to call an arbitrary pointer at an offset from `rdx`, which we can control. We then call another gadget from within the `setcontext` function in libc, which allows for setting almost all of the registers (including `rsp`) with data from an offset of `rdx`. This `setcontext` gadget is generally of the form:

```asm
000580dd  488ba2a0000000     mov     rsp, qword [rdx+0xa0]
000580e4  488b9a80000000     mov     rbx, qword [rdx+0x80]
000580eb  488b6a78           mov     rbp, qword [rdx+0x78]
000580ef  4c8b6248           mov     r12, qword [rdx+0x48]
000580f3  4c8b6a50           mov     r13, qword [rdx+0x50]
000580f7  4c8b7258           mov     r14, qword [rdx+0x58]
000580fb  4c8b7a60           mov     r15, qword [rdx+0x60]
000580ff  64f7042548000000…  test    dword [fs:0x48], 0x2
0005810b  0f84b5000000       je      0x581c6
...
000581c6  488b8aa8000000     mov     rcx, qword [rdx+0xa8]
000581cd  51                 push    rcx
000581ce  488b7270           mov     rsi, qword [rdx+0x70]
000581d2  488b7a68           mov     rdi, qword [rdx+0x68]
000581d6  488b8a98000000     mov     rcx, qword [rdx+0x98]
000581dd  4c8b4228           mov     r8, qword [rdx+0x28]
000581e1  4c8b4a30           mov     r9, qword [rdx+0x30]
000581e5  488b9288000000     mov     rdx, qword [rdx+0x88]
000581ec  31c0               xor     eax, eax  {0x0}
000581ee  c3                 retn
```

Since we can control `rsp`, we can stack pivot to some location on the heap. This can be used to pivot into a ROP chain also stored on the heap.

This `setcontext` code is actually part of the execution context reconstruction that occurs when recovering from a `sigreturn` syscall, so we can use the [`SigreturnFrame` class](https://github.com/Gallopsled/pwntools/blob/957a5a5835/pwnlib/rop/srop.py#L251) from `pwntools` to build a buffer with our desired register values at the correct offsets.

### 2.32 Mitigations (Safe List Unlinking)

glibc 2.32 introduced a few security mitigations, the most notable being the introduction of pointer mangling to the `fd` pointers of the singly-linked heap bins (i.e., tcache and fastbins). An awesome writeup that involves overcoming a lot of these new issues can be found [here](https://www.willsroot.io/2020/12/yet-another-house-asis-finals-2020-ctf.html).

### File Stream Exploitation

There is a whole class of CTF challenges related to exploitation of file streams (aka, the objects you point to with `FILE *` pointers).

An example abusing a double-free of a file stream can be found in [`kvstore` from zer0pts CTF 2022](https://hackmd.io/@ptr-yudai/r1jOWBvz9).

## Exploiting Memory Mapping Behavior

This is an interesting area of binary exploitation that requires corner case knowledge of memory allocation behavior. Understanding how pages are mapped, the various tricks you can perform with `mmap` flags, and what syscalls interface with the kernel's allocation logic can be powerful The best entrypoint into this arena is the talk [Large memory management vulnerabilities](https://cansecwest.com/core05/memory_vulns_delalleau.pdf). It's from 2005, but lays the groundwork for how to think about this kind of exploitation.

### Overlapping Pages

It turns out that `mmap` will happily provided pages mapped over existing memory segments. [This writeup](https://ctftime.org/writeup/25389) documents a challenge which involves (ab)using this `mmap` behavior to overwrite a portion of the libc that (was) mapped into memory.

The issue of overlapping pages with `mmap` is also discussed in [this StackOverflow Q/A](https://stackoverflow.com/questions/14943990/overlapping-pages-with-mmap-map-fixed#1494935213).

### `MAP_GROWSDOWN`

This `mmap` flag can be used to implicitly create pages at lower addresses on page faults. A writeup that explores this can be found [here](https://devcraft.io/2018/06/26/execve-sandbox-google-ctf-2018.html).

### Inferences from Consecutively-mapped Pages

[This writeup](https://bronson113.github.io/2022/07/05/segfault-labyrinth-GoogleCTF2022.html) from Google CTF 2022 demonstrates an ASLR bypass (within shellcode) that infers the libc base address based on an offset from an address returned by `mmap`.

## Linux Kernel Exploitation

### General Resources

Some pages with good snippets for random kernel-related tasks:

* [This blog](https://grosquildu.github.io/pentests/exp/)

Some of the best Linux kernel exploitation writeups I've read are based around Android privilege escalation. Some highlights include:

* [Google Project Zero: An iOS hacker tries Android](https://googleprojectzero.blogspot.com/2020/12/an-ios-hacker-tries-android.html?m=1): Explores some subtleties of [`vmalloc`](https://stackoverflow.com/questions/116343/what-is-the-difference-between-vmalloc-and-kmalloc) allocations, the [ION memory allocator](https://lwn.net/Articles/480055/), techniques for changing relative writes into code execution, and `userfaultfd` alternatives for achieving reliable blocking operations.

### `ptrace` Vulnerabilities

`ptrace` functionality and behavior has been the source of many Linux privilege escalation techniques over the years. Here are some links to look into related to the topic:

* [wisdom2 from hxp CTF 2020](https://ctftime.org/task/14372): [This solution](https://hxp.io/blog/79/hxp-CTF-2020-wisdom2/) uses a flaw in SerenityOS's `execve` paired with `PTRACE_POKE` to escalate privileges. [This solution](https://github.com/allesctf/writeups/blob/master/2020/hxpctf/wisdom2/writeup.md) abuses a flaw in SerenityOS's `PT_SETREGS` implementation, which allows for setting the `eflags` register to an arbitrary value.

### Swap Space

See [this writeup](https://mem2019.github.io/jekyll/update/2020/12/21/hxp2020-pfoten.html) for the pfoten challenge from hxp CTF 2020 for a unique kernel challenge that involves exploiting a writable swap space file.

### kASLR

kASLR is address randomization as applied to the kernel. Some resources for Linux kASLR:

* [Function Granular kASLR](https://lwn.net/Articles/824307/): "It rearranges your kernel code at load time on a per-function level granularity, with only around a second added to boot time."
* [kernel-rop from hxp CTF 2020](https://hxp.io/blog/81/hxp-CTF-2020-kernel-rop/): Abuses the fact that function granula kASLR leaves some static gadgets. Also see [this solution](https://gist.github.com/elnx/bc7980ca8f47dbc0e0cef8eb66e6245d) for an interesting technique that abuses `modprobe` behavior for an alternative privilege escalation technique.

#### EntryBleed

`EntryBleed` is a flaw in the Linux KPTI implementation that can lead to a kASLR bypass. Some helpful resources:

* [EntryBleed: Breaking KASLR under KPTI with Prefetch (CVE-2022-4543)](https://www.willsroot.io/2022/12/entrybleed.html)
* [POC that works on most Intel/AMD chips](https://github.com/bcoles/kasld/blob/master/src/entrybleed.c)

### Rings of Execution

Recommend reading [this StackOverflow Q/A](https://stackoverflow.com/questions/18717016/what-are-ring-0-and-ring-3-in-the-context-of-operating-systems).

#### Below Ring 0

TODO

#### x86 Design Flaws

I haven't come across any CTF challenges that involve this topic, but the documentation around the [sinkhole attack](https://github.com/xoreaxeaxeax/sinkhole) presented by Christopher Domas has proven to be a great learning resource. [Here](https://www.youtube.com/watch?v=lR0nh-TdpVg) is the accompanying BlackHat talk.

### `sysret` bugs

[`sysret`](https://www.felixcloutier.com/x86/sysret) is an x86/amd64 instruction that has led to a variety of kernel bugs over the years. This is explored (with comprehensive background) in the following blog posts:

* Two posts discussing the corCTF 2023 challenge `Sysruption`: [Exploiting Sysret on Linux in 2023](https://www.willsroot.io/2023/08/sysruption.html) and [corCTF 2023: sysruption writeup](https://zolutal.github.io/corctf-sysruption/)
* [CVE-2012-0217: Intel's sysret Kernel Privilege Escalation (on FreeBSD)](https://fail0verflow.com/blog/2012/cve-2012-0217-intel-sysret-freebsd/)
* [The Intel SYSRET privilege escalation](https://web.archive.org/web/20130710060213/blog.xen.org/index.php/2012/06/13/the-intel-sysret-privilege-escalation/)

### SerenityOS

[SerenityOS](https://github.com/SerenityOS/serenity) has been a fun target of exploitation in some CTFs. Quality writeups include:

* [SerenityOS - Writing a full chain exploit](https://devcraft.io/2021/02/11/serenityos-writing-a-full-chain-exploit.html)
* [qSerenityOS: Kernel Hacking Adventures](https://abigpickle.github.io/posts/2021/03/serenityos-kernel-hacking-adventures/)

## Emulation

### QEMU

[QEMU](https://www.qemu.org/) is an amazing feat of engineering. QEMU is a processor emulator capable of full-system emulation, user-mode binary emulation, and virtualization. It is an awesome tool for running CTF binaries built for different architectures.

To dive into applications of QEMU for emulating processors, the best guide I've seen can be found [here](https://johv.dk/blog/bare-metal-assembly-tutorial.html).

#### Booting from an ISO

If you are given an ISO with a custom boot loader / OS, QEMU can handle it for you. I've found these snippets useful:

```sh
# Mount the ISO to do some analysis of the files, figure out the arch, etc.
sudo mount -o loop custom-os.iso /media/cdrom

# Unmount before booting.
sudo umount /media/cdrom

# Use QEMU to boot into the OS (arch-dependent).
qemu-system-x86_64 -drive format=raw,media=cdrom,readonly,file=custom-os.iso
```

#### Emulating Old Linux Distros

If you are dealing with a binary linked against an insanely old version of glibc, a quick win might just be firing it up in an equally old OS. These resources can help get you there:

* [qemu-images](https://github.com/palmercluff/qemu-images): This repo contains ready-to-go QEMU images for old distros. The quickest option to go with from this list.
* [Test driving old Linux distros](https://opensource.com/article/16/12/yearbook-linux-test-driving-distros): An article that boots some old Linux OS ISOs and coveres some details of the process.
* [soft.lafibre.info](https://soft.lafibre.info/): A website that hosts a lot of old OS ISOs.

When working with pre-existing QEMU disk images, it can be useful to write files into those images before booting them:

```sh
# Install dependencies.
sudo apt-get install libguestfs-tools

# Write a local file myfile.txt into the image.
virt-sysprep -a debian-3.0.r6.qcow2 --upload ./local/path/to/myfile.txt:/img/path/to/myfile.txt

# Boot our image with some port forwarding.
qemu-system-i386 -hda debian-3.0.r6.qcow2 -m 256 -net nic -net user,hostfwd=tcp::10022-:22 -net nic -net user,hostfwd=tcp::10022-:22
```

### Unicorn Engine

While QEMU is a great engine for full machine virtualization and execution of binary executable files (ELF, PE, etc.), the [Unicorn Engine](https://www.unicorn-engine.org/) is a project that can peform emulation at the processor statement level.

I usually find myself reaching for the [Python bindings](https://github.com/unicorn-engine/unicorn/tree/master/bindings/python), which include many examples for a variety of architectures.

Some challenges even involve exploitation of programs emulated in unicorn. A great example of this is the challenge Pwnception from pbctf 2020. A thorough writeup for it can be found [here](https://faraz.faith/2020-12-08-pbctf-pwnception/).

### `kexec`-ing in Userspace

This isn't as much in the realm of emulation, but in my mind it fits into this section. For some challenges, being able to `kexec` into a new kernel in userspace is useful. To do that, see the [kexec-tools](https://github.com/horms/kexec-tools) project. [This writeup](https://ctftime.org/writeup/19151) by the p4 team goes over how to use it in some scenarios.

## PHP Exploitation

See [this link](https://www.blackarrow.net/disable-functions-bypasses-and-php-exploitation/) for a guide to PHP exploitation.

## Debugging on Windows

[x64dbg](https://x64dbg.com) is a nice FOSS debugger for Windows. See [this StackOverflow answer](https://reverseengineering.stackexchange.com/questions/22494/how-to-use-memory-address-information-from-idafree-to-set-a-breakpoint-in-x32dbg/22498#22498) for tips on aligning its loaded base address with other disassembly tools.
